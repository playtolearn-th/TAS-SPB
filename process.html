<!DOCTYPE html>
<html lang="th">
<head>
    <meta charset="UTF-8">
    <title>‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡πÄ‡∏ß‡∏•‡∏≤ - TAS-SPB</title>
    <link rel="icon" type="image/png" href="favicon.png">
    <style>
        body { font-family: 'Sarabun', sans-serif; background: #f8fafc; padding: 20px; display: flex; flex-direction: column; align-items: center; }
        .container { width: 100%; max-width: 700px; background: white; padding: 30px; border-radius: 15px; box-shadow: 0 4px 10px rgba(0,0,0,0.05); text-align: center; }
        
        /* ‡∏õ‡∏∏‡πà‡∏° Start */
        .btn-process { background: linear-gradient(135deg, #8b5cf6, #6366f1); color: white; border: none; padding: 15px 30px; border-radius: 30px; font-size: 1.2rem; font-weight: bold; cursor: pointer; margin: 20px 0; box-shadow: 0 4px 6px rgba(99, 102, 241, 0.3); transition: transform 0.2s; width: 100%; }
        .btn-process:active { transform: scale(0.95); }
        .btn-process:disabled { background: #cbd5e1; cursor: not-allowed; transform: none; box-shadow: none; }
        
        /* Log Box */
        .log-box { text-align: left; background: #1e293b; color: #10b981; border-radius: 10px; padding: 15px; height: 350px; overflow-y: auto; font-family: monospace; font-size: 0.9rem; border: 1px solid #e2e8f0; }
        .back-btn { text-decoration: none; color: #64748b; font-weight: bold; display: inline-block; margin-bottom: 20px; }
        
        /* Log Colors */
        .highlight { color: #fbbf24; } 
        .error { color: #ef4444; } 
        .info { color: #60a5fa; }
        .timestamp { color: #94a3b8; margin-right: 5px; }

        /* Controls */
        .controls { display: flex; flex-direction: column; gap: 15px; margin-bottom: 20px; background: #f1f5f9; padding: 15px; border-radius: 10px; text-align: left; }
        .radio-group { display: flex; gap: 20px; margin-bottom: 10px; }
        .radio-group label { cursor: pointer; font-weight: bold; color: #475569; display: flex; align-items: center; gap: 5px; }
        .date-input-group { display: flex; gap: 10px; align-items: center; }
        input[type="date"] { padding: 8px; border: 1px solid #cbd5e1; border-radius: 5px; font-family: 'Sarabun'; }
        input[type="date"]:disabled { background: #e2e8f0; color: #94a3b8; cursor: not-allowed; }
    </style>
    
    <script src="supabase.js"></script>
    <script src="sweetalert2.js"></script>
    <script src="config.js"></script>
</head>
<body>
    <a href="menu.html" class="back-btn">‚¨Ö ‡∏Å‡∏•‡∏±‡∏ö‡πÄ‡∏°‡∏ô‡∏π‡∏´‡∏•‡∏±‡∏Å</a>

    <div class="container">
        <h2>üîÑ ‡∏£‡∏∞‡∏ö‡∏ö‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡πÄ‡∏ß‡∏•‡∏≤</h2>
        <p>‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏≤‡∏Å‡πÄ‡∏ß‡πá‡∏ö‡∏£‡∏≤‡∏¢‡∏á‡∏≤‡∏ô (HTTP) ‡πÅ‡∏•‡∏∞ ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏†‡∏≤‡∏¢‡πÉ‡∏ô (Manual) ‡∏°‡∏≤‡∏£‡∏ß‡∏°‡∏Å‡∏±‡∏ô</p>
        
        <div class="controls">
            <div class="radio-group">
                <label>
                    <input type="radio" name="processMode" value="auto" checked onchange="toggleInputs()"> 
                    ü§ñ Auto Sync (‡∏ï‡πà‡∏≠‡πÄ‡∏ô‡∏∑‡πà‡∏≠‡∏á‡∏à‡∏≤‡∏Å‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î)
                </label>
                <label>
                    <input type="radio" name="processMode" value="manual" onchange="toggleInputs()"> 
                    üìÖ ‡∏£‡∏∞‡∏ö‡∏∏‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡πÄ‡∏≠‡∏á
                </label>
            </div>
            
            <div class="date-input-group" id="manualDateGroup" style="opacity: 0.5; pointer-events: none;">
                <label>‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà:</label>
                <input type="date" id="manualDate" value="">
                <span>‡∏ñ‡∏∂‡∏á</span>
                <input type="date" id="manualDateEnd" value="">
            </div>
        </div>

        <button id="btnStart" class="btn-process" onclick="startProcess()">üöÄ ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏Å‡∏≤‡∏£‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•</button>
        
        <div class="log-box" id="logDisplay">
            > ‡∏£‡∏≠‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ó‡∏≥‡∏á‡∏≤‡∏ô...
        </div>
    </div>

    <script>
        const user = checkAuth();

        // ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡πÉ‡∏´‡πâ‡∏Å‡∏±‡∏ö Input Manual (‡πÄ‡∏õ‡πá‡∏ô‡∏ß‡∏±‡∏ô‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô)
        document.addEventListener('DOMContentLoaded', () => {
            const todayStr = new Date().toISOString().split('T')[0];
            document.getElementById('manualDate').value = todayStr;
            document.getElementById('manualDateEnd').value = todayStr;
        });

        function toggleInputs() {
            const mode = document.querySelector('input[name="processMode"]:checked').value;
            const group = document.getElementById('manualDateGroup');
            const inputs = group.querySelectorAll('input');
            
            if (mode === 'manual') {
                group.style.opacity = '1';
                group.style.pointerEvents = 'auto';
                inputs.forEach(i => i.disabled = false);
            } else {
                group.style.opacity = '0.5';
                group.style.pointerEvents = 'none';
                inputs.forEach(i => i.disabled = true);
            }
        }

        function getTimeStr() {
            const now = new Date();
            return `[${String(now.getHours()).padStart(2,'0')}:${String(now.getMinutes()).padStart(2,'0')}:${String(now.getSeconds()).padStart(2,'0')}]`;
        }

        function log(msg, type = 'normal') {
            const box = document.getElementById('logDisplay');
            let colorClass = '';
            if(type === 'highlight') colorClass = 'class="highlight"';
            if(type === 'error') colorClass = 'class="error"';
            if(type === 'info') colorClass = 'class="info"';
            
            box.innerHTML += `<div ${colorClass}><span class="timestamp">${getTimeStr()}</span> ${msg}</div>`;
            box.scrollTop = box.scrollHeight;
        }

        function formatDateDB(date) {
            const pad = (n) => String(n).padStart(2, '0');
            return `${date.getFullYear()}-${pad(date.getMonth() + 1)}-${pad(date.getDate())}`;
        }

        function formatDateURL(date) {
            const pad = (n) => String(n).padStart(2, '0');
            return `${pad(date.getDate())}${pad(date.getMonth() + 1)}${date.getFullYear()}`;
        }

        // --- Scraping Logic ---
        function parseHTMLTable(htmlString, dateStr) {
            const parser = new DOMParser();
            const doc = parser.parseFromString(htmlString, "text/html");
            const table = doc.getElementById('mainTable');
            const records = [];

            if (!table) return [];

            const rows = table.querySelectorAll('tbody tr');
            rows.forEach(row => {
                const cols = row.querySelectorAll('td');
                if (cols.length >= 4) {
                    const pid = cols[0].innerText.trim();
                    const name = cols[1].innerText.trim();
                    let t_in = cols[2].innerText.trim();
                    let t_out = cols[3].innerText.trim();

                    if(t_in === "" || t_in === "-") t_in = null;
                    else if(t_in.length === 5) t_in += ":00";

                    if(t_out === "" || t_out === "-") t_out = null;
                    else if(t_out.length === 5) t_out += ":00";

                    if (pid && pid !== "‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•") { // ‡∏Å‡∏±‡∏ô‡∏Å‡∏£‡∏ì‡∏µ‡∏ï‡∏≤‡∏£‡∏≤‡∏á‡∏ß‡πà‡∏≤‡∏á‡πÅ‡∏•‡πâ‡∏ß‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏° error
                        records.push({
                            personnel_id: pid,
                            full_name: name,
                            work_date: dateStr,
                            time_in: t_in,
                            time_out: t_out
                        });
                    }
                }
            });
            return records;
        }

        async function startProcess() {
            const btn = document.getElementById('btnStart');
            const mode = document.querySelector('input[name="processMode"]:checked').value;
            
            btn.disabled = true;
            document.getElementById('logDisplay').innerHTML = ''; // ‡πÄ‡∏Ñ‡∏•‡∏µ‡∏¢‡∏£‡πå log ‡πÄ‡∏Å‡πà‡∏≤
            
            log(`Starting process engine... Mode: ${mode.toUpperCase()}`);

            try {
                // 1. ‡πÄ‡∏ï‡∏£‡∏µ‡∏¢‡∏° Base URL
                log("Connecting to settings...");
                const { data: settingData } = await sbClient.from(TAS_CONFIG.TABLE_SETTINGS)
                    .select('value').eq('key', 'data_url').single();
                
                let baseURL = "";
                if (settingData && settingData.value) {
                    let rawUrl = settingData.value;
                    // Clean URL logic
                    if(rawUrl.includes("api.allorigins.win")) {
                        const match = rawUrl.match(/url=(.*)/);
                        if(match) rawUrl = decodeURIComponent(match[1]);
                    }
                    if(!rawUrl.endsWith('/')) rawUrl += '/';
                    
                    // ‡πÉ‡∏ä‡πâ Proxy ‡πÄ‡∏™‡∏°‡∏≠
                    baseURL = `https://api.allorigins.win/get?url=${encodeURIComponent(rawUrl)}`;
                    log(`Proxy configured for: ${rawUrl}`, 'info');
                } else {
                    log("‚ö†Ô∏è Warning: ‡πÑ‡∏°‡πà‡∏û‡∏ö 'data_url' ‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤ (‡∏à‡∏∞‡∏î‡∏∂‡∏á‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏†‡∏≤‡∏¢‡πÉ‡∏ô)", 'error');
                }

                // 2. ‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏ä‡πà‡∏ß‡∏á‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà (Loop Range)
                let startDate = new Date();
                let endDate = new Date();

                if (mode === 'manual') {
                    // ‡πÇ‡∏´‡∏°‡∏î‡∏£‡∏∞‡∏ö‡∏∏‡∏ß‡∏±‡∏ô
                    const sDateVal = document.getElementById('manualDate').value;
                    const eDateVal = document.getElementById('manualDateEnd').value;
                    if(!sDateVal || !eDateVal) throw new Error("‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏£‡∏∞‡∏ö‡∏∏‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡πÉ‡∏´‡πâ‡∏Ñ‡∏£‡∏ö‡∏ñ‡πâ‡∏ß‡∏ô");
                    
                    startDate = new Date(sDateVal);
                    endDate = new Date(eDateVal);
                    log(`Manual Range: ${sDateVal} to ${eDateVal}`, 'highlight');

                } else {
                    // ‡πÇ‡∏´‡∏°‡∏î Auto
                    log("Checking latest record in database...");
                    const { data: latestRecord } = await sbClient.from(TAS_CONFIG.TABLE_TARGET)
                        .select('work_date').order('work_date', { ascending: false }).limit(1).single();

                    if (latestRecord && latestRecord.work_date) {
                        startDate = new Date(latestRecord.work_date);
                        log(`Found latest date: ${latestRecord.work_date}`, 'info');
                        // ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ó‡∏µ‡πà‡∏ß‡∏±‡∏ô‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î (‡πÄ‡∏û‡∏∑‡πà‡∏≠ Update ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏ú‡∏∑‡πà‡∏≠‡∏°‡∏µ‡∏Å‡∏≤‡∏£‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç)
                    } else {
                        log("No previous records found. Starting from TODAY.", 'info');
                    }
                    // End date ‡∏Ñ‡∏∑‡∏≠‡∏ß‡∏±‡∏ô‡∏ô‡∏µ‡πâ‡πÄ‡∏™‡∏°‡∏≠‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö Auto
                    endDate = new Date();
                }

                // 3. ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ß‡∏ô‡∏•‡∏π‡∏õ
                startDate.setHours(0,0,0,0);
                endDate.setHours(0,0,0,0);
                
                let loopDate = new Date(startDate);
                let totalSaved = 0;

                while (loopDate <= endDate) {
                    const dateDBStr = formatDateDB(loopDate);   
                    const dateURLPart = formatDateURL(loopDate); 
                    
                    log(`-----------------------------------`);
                    log(`Processing Date: ${dateDBStr}...`, 'highlight');

                    // 3.1 ‡∏î‡∏∂‡∏á Web ‡∏ô‡∏≠‡∏Å
                    let externalData = [];
                    if (baseURL) {
                        try {
                            const targetUrl = `${baseURL.split('url=')[1]}${dateURLPart}`; // hack ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏õ‡∏£‡∏∞‡∏Å‡∏≠‡∏ö‡∏£‡πà‡∏≤‡∏á url ‡πÉ‡∏ô proxy
                            const finalProxyUrl = `https://api.allorigins.win/get?url=${targetUrl}`;
                            
                            const res = await fetch(finalProxyUrl);
                            if (res.ok) {
                                const jsonRes = await res.json();
                                externalData = parseHTMLTable(jsonRes.contents, dateDBStr);
                                log(`   [External] Fetched ${externalData.length} records.`);
                            } else {
                                log(`   [External] HTTP Error ${res.status}`, 'error');
                            }
                        } catch (e) {
                            log(`   [External] Failed: ${e.message}`, 'error');
                        }
                    }

                    // 3.2 ‡∏î‡∏∂‡∏á DB ‡∏†‡∏≤‡∏¢‡πÉ‡∏ô (TimeStampPlus)
                    const { data: internalData, error: errInt } = await sbClient
                        .from(TAS_CONFIG.TABLE_SOURCE).select('*').eq('work_date', dateDBStr);
                    
                    if(errInt) log(`   [Internal] DB Error: ${errInt.message}`, 'error');
                    else log(`   [Internal] Found ${internalData ? internalData.length : 0} records.`);

                    // 3.3 Merge
                    const mergedMap = {};
                    const processRecord = (rec) => {
                        const pid = rec.personnel_id;
                        if (!mergedMap[pid]) {
                            mergedMap[pid] = {
                                personnel_id: pid,
                                full_name: rec.full_name || rec.name,
                                work_date: dateDBStr,
                                time_in: rec.time_in,
                                time_out: rec.time_out
                            };
                        } else {
                            const current = mergedMap[pid];
                            // Logic: ‡πÄ‡∏≠‡∏≤‡πÄ‡∏ß‡∏•‡∏≤‡πÄ‡∏Ç‡πâ‡∏≤‡∏ó‡∏µ‡πà‡∏ô‡πâ‡∏≠‡∏¢‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î ‡πÅ‡∏•‡∏∞‡πÄ‡∏ß‡∏•‡∏≤‡∏≠‡∏≠‡∏Å‡∏ó‡∏µ‡πà‡∏°‡∏≤‡∏Å‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î
                            if (rec.time_in && (!current.time_in || rec.time_in < current.time_in)) current.time_in = rec.time_in;
                            if (rec.time_out && (!current.time_out || rec.time_out > current.time_out)) current.time_out = rec.time_out;
                        }
                    };

                    if (externalData.length > 0) externalData.forEach(processRecord);
                    if (internalData && internalData.length > 0) internalData.forEach(processRecord);

                    const finalData = Object.values(mergedMap);

                    // 3.4 Save to Target (TimeStamp)
                    if (finalData.length > 0) {
                        const recordsToSave = finalData.map(item => ({
                            id: `${formatDateURL(new Date(item.work_date))}${item.personnel_id}`,
                            personnel_id: item.personnel_id,
                            full_name: item.full_name,
                            work_date: item.work_date,
                            time_in: item.time_in,
                            time_out: item.time_out,
                            verified: 0 // Default value
                        }));

                        const { error: errUpsert } = await sbClient
                            .from(TAS_CONFIG.TABLE_TARGET)
                            .upsert(recordsToSave, { onConflict: 'personnel_id, work_date' });

                        if (errUpsert) {
                            log(`   ‚ùå Save Failed: ${errUpsert.message}`, 'error');
                        } else {
                            log(`   üíæ Saved ${recordsToSave.length} records successfully.`, 'info');
                            totalSaved += recordsToSave.length;
                        }
                    } else {
                        log(`   (No data to save for this date)`);
                    }

                    // ‡∏Ç‡∏¢‡∏±‡∏ö‡∏ß‡∏±‡∏ô‡∏ñ‡∏±‡∏î‡πÑ‡∏õ
                    loopDate.setDate(loopDate.getDate() + 1);
                }

                log(`-----------------------------------`);
                log(`All operations completed. Total Saved: ${totalSaved}`, 'highlight');
                
                if(totalSaved > 0) Swal.fire('‡πÄ‡∏™‡∏£‡πá‡∏à‡∏™‡∏¥‡πâ‡∏ô', `‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÅ‡∏•‡πâ‡∏ß ${totalSaved} ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£`, 'success');
                else Swal.fire('‡πÄ‡∏™‡∏£‡πá‡∏à‡∏™‡∏¥‡πâ‡∏ô', '‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÉ‡∏´‡∏°‡πà‡πÉ‡∏ô‡∏ä‡πà‡∏ß‡∏á‡πÄ‡∏ß‡∏•‡∏≤‡∏ó‡∏µ‡πà‡πÄ‡∏•‡∏∑‡∏≠‡∏Å', 'info');

            } catch (err) {
                console.error(err);
                log(`CRITICAL ERROR: ${err.message}`, 'error');
                Swal.fire('Error', err.message, 'error');
            } finally {
                btn.disabled = false;
            }
        }
    </script>
</body>
</html>
