<!DOCTYPE html>
<html lang="th">
<head>
    <meta charset="UTF-8">
    <title>‡∏£‡∏∞‡∏ö‡∏ö‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡πÄ‡∏ß‡∏•‡∏≤ (Detailed Monitor) - TAS-SPB</title>
    <link rel="icon" type="image/png" href="favicon.png">
    <style>
        body { font-family: 'Sarabun', sans-serif; background: #f1f5f9; padding: 20px; display: flex; flex-direction: column; align-items: center; }
        .container { width: 100%; max-width: 800px; background: white; padding: 30px; border-radius: 15px; box-shadow: 0 4px 15px rgba(0,0,0,0.1); }
        
        h2 { text-align: center; color: #1e293b; margin-bottom: 25px; }

        /* Control Panel */
        .controls { background: #f8fafc; padding: 20px; border-radius: 10px; border: 1px solid #e2e8f0; margin-bottom: 20px; }
        .control-row { display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; flex-wrap: wrap; gap: 10px; }
        
        .radio-group label { margin-right: 15px; cursor: pointer; font-weight: 600; color: #475569; }
        .date-inputs { display: flex; align-items: center; gap: 10px; opacity: 0.5; pointer-events: none; transition: 0.3s; }
        .date-inputs.active { opacity: 1; pointer-events: auto; }
        input[type="date"] { padding: 8px; border: 1px solid #cbd5e1; border-radius: 6px; font-family: 'Sarabun'; }

        /* Start Button */
        .btn-start { width: 100%; background: linear-gradient(135deg, #3b82f6, #2563eb); color: white; border: none; padding: 15px; font-size: 1.1rem; font-weight: bold; border-radius: 8px; cursor: pointer; transition: 0.2s; box-shadow: 0 4px 6px rgba(37, 99, 235, 0.2); }
        .btn-start:hover { background: linear-gradient(135deg, #2563eb, #1d4ed8); transform: translateY(-1px); }
        .btn-start:disabled { background: #94a3b8; cursor: not-allowed; transform: none; }

        /* Log Monitor */
        .log-container { margin-top: 20px; border: 1px solid #334155; border-radius: 8px; overflow: hidden; background: #0f172a; }
        .log-header { background: #1e293b; color: #e2e8f0; padding: 10px 15px; font-weight: bold; font-size: 0.9rem; display: flex; justify-content: space-between; border-bottom: 1px solid #334155; }
        .log-content { height: 400px; overflow-y: auto; padding: 15px; font-family: 'Consolas', 'Monaco', monospace; font-size: 0.85rem; color: #cbd5e1; line-height: 1.6; }

        /* Log Styling */
        .log-line { margin-bottom: 4px; border-bottom: 1px dashed #334155; padding-bottom: 2px; }
        .ts { color: #64748b; margin-right: 8px; font-size: 0.8rem; }
        .tag { padding: 2px 6px; border-radius: 4px; font-size: 0.75rem; font-weight: bold; margin-right: 6px; }
        
        .tag.info { background: #3b82f6; color: white; }
        .tag.success { background: #10b981; color: white; }
        .tag.warn { background: #f59e0b; color: white; }
        .tag.error { background: #ef4444; color: white; }
        .tag.web { background: #8b5cf6; color: white; } /* Purple */
        .tag.db { background: #ec4899; color: white; }  /* Pink */

        .detail-item { padding-left: 20px; color: #94a3b8; font-size: 0.8rem; }
        .highlight { color: #facc15; font-weight: bold; }
        
        .back-link { display: inline-block; margin-bottom: 15px; text-decoration: none; color: #64748b; font-weight: 600; }
    </style>
    
    <script src="supabase.js"></script>
    <script src="sweetalert2.js"></script>
    <script src="config.js"></script>
</head>
<body>
    <a href="menu.html" class="back-link">‚¨Ö ‡∏Å‡∏•‡∏±‡∏ö‡πÄ‡∏°‡∏ô‡∏π‡∏´‡∏•‡∏±‡∏Å</a>

    <div class="container">
        <h2>üìü Monitor: ‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡πÄ‡∏ß‡∏•‡∏≤‡πÄ‡∏Ç‡πâ‡∏≤-‡∏≠‡∏≠‡∏Å</h2>
        
        <div class="controls">
            <div class="control-row">
                <div class="radio-group">
                    <label><input type="radio" name="mode" value="auto" checked onchange="toggleDate(false)"> ü§ñ Auto Sync (‡∏ï‡πà‡∏≠‡πÄ‡∏ô‡∏∑‡πà‡∏≠‡∏á)</label>
                    <label><input type="radio" name="mode" value="manual" onchange="toggleDate(true)"> üìÖ ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡πÄ‡∏≠‡∏á</label>
                </div>
                <div class="checkbox-group">
                     <label><input type="checkbox" id="chkVerbose" checked> ‡πÅ‡∏™‡∏î‡∏á‡∏£‡∏≤‡∏¢‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î‡∏£‡∏≤‡∏¢‡∏ö‡∏∏‡∏Ñ‡∏Ñ‡∏•</label>
                </div>
            </div>
            
            <div class="date-inputs" id="dateGroup">
                <span>‡∏à‡∏≤‡∏Å:</span> <input type="date" id="startDate">
                <span>‡∏ñ‡∏∂‡∏á:</span> <input type="date" id="endDate">
            </div>
        </div>

        <button id="btnStart" class="btn-start" onclick="runProcess()">üöÄ ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏Å‡∏≤‡∏£‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏• (Start Process)</button>

        <div class="log-container">
            <div class="log-header">
                <span>Console Output</span>
                <span id="statusText">Ready</span>
            </div>
            <div class="log-content" id="logBox">
                <div class="log-line">> System Ready... Waiting for command.</div>
            </div>
        </div>
    </div>

    <script>
        const user = checkAuth();

        // Init Date Inputs
        const today = new Date().toISOString().split('T')[0];
        document.getElementById('startDate').value = today;
        document.getElementById('endDate').value = today;

        function toggleDate(enable) {
            const el = document.getElementById('dateGroup');
            if(enable) el.classList.add('active');
            else el.classList.remove('active');
        }

        function log(msg, type = 'normal', detail = null) {
            const box = document.getElementById('logBox');
            const now = new Date();
            const ts = `[${String(now.getHours()).padStart(2,'0')}:${String(now.getMinutes()).padStart(2,'0')}:${String(now.getSeconds()).padStart(2,'0')}]`;
            
            let tagHtml = '';
            if(type === 'info') tagHtml = `<span class="tag info">INFO</span>`;
            if(type === 'success') tagHtml = `<span class="tag success">OK</span>`;
            if(type === 'warn') tagHtml = `<span class="tag warn">WARN</span>`;
            if(type === 'error') tagHtml = `<span class="tag error">ERR</span>`;
            if(type === 'web') tagHtml = `<span class="tag web">WEB</span>`;
            if(type === 'db') tagHtml = `<span class="tag db">DB</span>`;

            let html = `<div class="log-line"><span class="ts">${ts}</span>${tagHtml} ${msg}</div>`;
            
            if(detail && document.getElementById('chkVerbose').checked) {
                html += `<div class="detail-item">${detail}</div>`;
            }

            box.innerHTML += html;
            box.scrollTop = box.scrollHeight;
        }

        // --- Helper Functions ---
        function formatDateDB(date) {
            const pad = (n) => String(n).padStart(2, '0');
            return `${date.getFullYear()}-${pad(date.getMonth() + 1)}-${pad(date.getDate())}`;
        }
        function formatDateURL(date) {
            const pad = (n) => String(n).padStart(2, '0');
            return `${pad(date.getDate())}${pad(date.getMonth() + 1)}${date.getFullYear()}`;
        }

        // --- Parser ---
        function parseHTMLTable(htmlString, dateStr) {
            const parser = new DOMParser();
            const doc = parser.parseFromString(htmlString, "text/html");
            const rows = doc.querySelectorAll('#mainTable tbody tr');
            const records = [];
            rows.forEach(row => {
                const cols = row.querySelectorAll('td');
                if (cols.length >= 4) {
                    const pid = cols[0].innerText.trim();
                    const name = cols[1].innerText.trim();
                    let t_in = cols[2].innerText.trim();
                    let t_out = cols[3].innerText.trim();

                    if(pid && pid !== "‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•") {
                        if(t_in === "-" || t_in === "") t_in = null; else if(t_in.length===5) t_in+=":00";
                        if(t_out === "-" || t_out === "") t_out = null; else if(t_out.length===5) t_out+=":00";
                        records.push({ personnel_id: pid, full_name: name, work_date: dateStr, time_in: t_in, time_out: t_out });
                    }
                }
            });
            return records;
        }

        // --- Main Engine ---
        async function runProcess() {
            const btn = document.getElementById('btnStart');
            const mode = document.querySelector('input[name="mode"]:checked').value;
            
            btn.disabled = true;
            document.getElementById('logBox').innerHTML = ''; 
            log("üöÄ Initializing Process Engine...", 'info');

            try {
                // 1. Get Config
                const { data: configData } = await sbClient.from(TAS_CONFIG.TABLE_SETTINGS).select('value').eq('key', 'data_url').single();
                let proxyUrl = "";
                if(configData?.value) {
                    let target = configData.value.replace("https://api.allorigins.win/get?url=", ""); 
                    if(!target.endsWith('/')) target += '/';
                    proxyUrl = target;
                    log(`Target URL: ${target}`, 'info');
                } else {
                    log("No 'data_url' setting found. Using Internal DB only.", 'warn');
                }

                // 2. Determine Date Range
                let start, end;
                if(mode === 'manual') {
                    start = new Date(document.getElementById('startDate').value);
                    end = new Date(document.getElementById('endDate').value);
                } else {
                    log("Checking last sync date...", 'info');
                    const { data: lastRec } = await sbClient.from(TAS_CONFIG.TABLE_TARGET)
                        .select('work_date').order('work_date', {ascending: false}).limit(1).single();
                    
                    if(lastRec) {
                        start = new Date(lastRec.work_date);
                        log(`Last synced: ${lastRec.work_date} -> Starting from there.`, 'info');
                    } else {
                        start = new Date();
                        log("No history found. Starting from Today.", 'info');
                    }
                    end = new Date(); // Today
                }

                start.setHours(0,0,0,0);
                end.setHours(0,0,0,0);

                // 3. Loop Dates
                let loop = new Date(start);
                let grandTotal = 0;

                while(loop <= end) {
                    const dateStr = formatDateDB(loop);
                    const urlDate = formatDateURL(loop);
                    
                    log(`----------------------------------------`);
                    log(`üìÖ Processing Date: <span class="highlight">${dateStr}</span>`, 'info');

                    // 3.1 Fetch Web
                    let webData = [];
                    if(proxyUrl) {
                        try {
                            const finalUrl = `https://api.allorigins.win/get?url=${encodeURIComponent(proxyUrl + urlDate)}`;
                            const res = await fetch(finalUrl);
                            if(res.ok) {
                                const json = await res.json();
                                webData = parseHTMLTable(json.contents, dateStr);
                                log(`Fetched Web Report`, 'web', `Found ${webData.length} records.`);
                            } else {
                                log(`HTTP Error ${res.status}`, 'error');
                            }
                        } catch(e) { log(`Fetch Web Failed: ${e.message}`, 'error'); }
                    }

                    // 3.2 Fetch Internal DB
                    let dbData = [];
                    const { data: internal, error: errInt } = await sbClient.from(TAS_CONFIG.TABLE_SOURCE)
                        .select('*').eq('work_date', dateStr);
                    if(!errInt && internal) {
                        dbData = internal;
                        log(`Fetched Internal DB`, 'db', `Found ${dbData.length} records.`);
                    }

                    // 3.3 Merge
                    const map = {};
                    const addToMap = (rec, source) => {
                        if(!map[rec.personnel_id]) {
                            map[rec.personnel_id] = { ...rec, sources: [source] };
                        } else {
                            const cur = map[rec.personnel_id];
                            cur.sources.push(source);
                            // Merge Logic: Best times
                            if(rec.time_in && (!cur.time_in || rec.time_in < cur.time_in)) cur.time_in = rec.time_in;
                            if(rec.time_out && (!cur.time_out || rec.time_out > cur.time_out)) cur.time_out = rec.time_out;
                        }
                    };

                    webData.forEach(r => addToMap(r, 'Web'));
                    dbData.forEach(r => addToMap(r, 'DB'));

                    const mergedList = Object.values(map);
                    
                    if(mergedList.length === 0) {
                        log("No data found for this date.", 'warn');
                    } else {
                        log(`Merging data... Total unique persons: ${mergedList.length}`, 'info');

                        // 3.4 Save
                        const payload = mergedList.map(item => ({
                            id: `${formatDateURL(new Date(item.work_date))}${item.personnel_id}`,
                            personnel_id: item.personnel_id,
                            full_name: item.full_name,
                            work_date: item.work_date,
                            time_in: item.time_in,
                            time_out: item.time_out,
                            verified: 0
                        }));

                        const { error: saveErr } = await sbClient.from(TAS_CONFIG.TABLE_TARGET)
                            .upsert(payload, { onConflict: 'personnel_id, work_date' });

                        if(saveErr) {
                            log(`Save Failed: ${saveErr.message}`, 'error');
                        } else {
                            log(`Saved ${payload.length} records to Database.`, 'success');
                            grandTotal += payload.length;

                            // Verbose Log for individuals
                            if(document.getElementById('chkVerbose').checked) {
                                payload.forEach(p => {
                                    const src = map[p.personnel_id].sources.join('+');
                                    log(`> ${p.full_name} (${p.personnel_id})`, 'normal', 
                                        `Time: ${p.time_in || '-'} / ${p.time_out || '-'} [Src: ${src}]`);
                                });
                            }
                        }
                    }
                    
                    loop.setDate(loop.getDate() + 1);
                    await new Promise(r => setTimeout(r, 500)); // Delay ‡∏Å‡∏±‡∏ô‡∏Ñ‡πâ‡∏≤‡∏á
                }

                log(`----------------------------------------`);
                log(`‚úÖ Operation Complete. Total Processed: ${grandTotal}`, 'success');
                Swal.fire('‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à', `‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡πÄ‡∏™‡∏£‡πá‡∏à‡∏™‡∏¥‡πâ‡∏ô‡∏£‡∏ß‡∏° ${grandTotal} ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£`, 'success');

            } catch (err) {
                console.error(err);
                log(`CRITICAL ERROR: ${err.message}`, 'error');
                Swal.fire('Error', err.message, 'error');
            } finally {
                btn.disabled = false;
                document.getElementById('statusText').innerText = 'Finished';
            }
        }
    </script>
</body>
</html>
